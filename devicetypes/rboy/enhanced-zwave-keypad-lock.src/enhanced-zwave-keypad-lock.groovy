/*
 * -----------------------
 * --- DEVICE HANDLER ----
 * -----------------------
 *
 * STOP:  Do NOT PUBLISH the code to GitHub, it is a VIOLATION of the license terms.
 * You are NOT allowed share, distribute, reuse or publicly host (e.g. GITHUB) the code. Refer to the license details on our website.
 *
 */

/* **DISCLAIMER**
* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
* 1. the software will meet your requirements or expectations;
* 2. the software or the software content will be free of bugs, errors, viruses or other defects;
* 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
* 4. the software will be compatible with third party software;
* 5. any errors in the software will be corrected.
* The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
*/ 

def clientVersion() {
    return "02.02.03"
}

/*
* Copyright RBoy Apps, redistribution or reuse of code or any changes is not allowed without permission
* Works with all Z-Wave and Z-Wave Plus Keypads including Ring
*
* Change Log
* 2020-11-13 - (v02.02.03) Catch platform errors on install to avoid ghost devices
* 2020-10-13 - (v02.02.02) Fix for not using number setting 0, ring siren volume not supported
* 2020-10-07 - (v02.02.00) Improved handling of out order events due to mesh delays which was causing codes to not work in some cases
* 2020-10-01 - (v02.01.01) Added option to select default keypad arm mode when "locked", "lock" keypad when armed and vice versa
* 2020-09-30 - (v02.00.00) New app UI and capabilities, fix for pin code timeout
* 2020-07-14 - (v01.00.00) Initial release
*
*/

metadata {
    definition (name: "Enhanced Z-Wave Keypad Lock", namespace: "rboy", author: "RBoy Apps", mnmn: "SmartThingsCommunity", vid: "1094f292-8ee2-3869-9650-582adae09e54", mcdSync: !separateDevices) {
        capability "Lock"
        capability "Refresh"
        capability "Sensor"
        capability "Lock Codes"
        capability "Battery"
        capability "Health Check"
        capability "Configuration"
        capability "Power Source"
		capability "Tone"
		capability "Button"
        capability "Alarm"
        //capability "Tamper Alert"
        //capability "Smoke Detector" //  TODO: Should we report a fire alarm button as a smoke event?
        //capability "Polling" // We'll do it manually for better control
        //capability "Motion Sensor" // Not reported yet
        capability "rboyapps.arming"
        capability "rboyapps.lockKeypad"
        capability "rboyapps.lockAutolock"
        capability "rboyapps.versioning"
        capability "rboyapps.lockExtended"

        //attribute "codeLength", "number" // TODO: Do we need to define this or is this automatically done now with the new DTH capability
        //attribute "maxCodeLength", "number" // TODO: Do we need to define this or is this automatically done now with the new DTH capability
        //attribute "minCodeLength", "number" // TODO: Do we need to define this or is this automatically done now with the new DTH capability
        //attribute "maxCodes", "number" // TODO: Do we need to define this or is this automatically done now with the new DTH capability
        
        // Internal attributes
        attribute "codeTimeout", "number"
        attribute "minCacheSize", "number"
        attribute "maxCacheSize", "number"
        attribute "lastMode", "string"
        attribute "lastPin", "string"

        ///attribute "armMode", "string"
        ///attribute "keypad", "string"
        ///attribute "autolock", "string"
        ///attribute "invalidCode", "string"
        ///attribute "codeVersion", "string"
        ///attribute "dhName", "string"
		
        ///command "setArmMode", ['string']
        ///command "setKeypad", ['string']
        ///command "setAutolock", ['string']
		///command "setDisarmed"
		///command "setArmedAway"
		///command "setArmedStay"
		///command "setArmedNight"
		///command "setExitDelay", ['number']
		///command "setEntryDelay", ['number']
		///command "sendInvalidKeycodeResponse"
		///command "acknowledgeArmRequest"
        ///command "disableKeypad"
        ///command "enableKeypad"
        ///command "enableAutolock"
        ///command "disableAutolock"
        command "clearPanic"
        command "disableInvalidPinLogging", ['boolean']


        // v1 format
        fingerprint deviceId: "0x400B", inClusters: "0x5E,0x59,0x85,0x80,0x70,0x5A,0x7A,0x87,0x72,0x8E,0x71,0x73,0x98,0x6C,0x55,0x86" // Ring

        // Keypads
        fingerprint type:"400B", mfr:"0346", prod:"0101", model:"0301", deviceJoinName:"Ring Alarm Keypad (2nd gen)" // zw:F type:400B mfr:0346 prod:0101 model:0301 ver:0.00 zwv:0.00 lib:00 cc:5E,59,85,80,70,5A,7A,87,72,8E,71,73,98,6C,55,86 role:07 ff:A001 ui:A001
    }

    preferences {
        input title: "", description: "Enhanced Z-Wave Keypad Device Handler v${clientVersion()}", displayDuringSetup: false, type: "paragraph", element: "paragraph", required: true

        input "pinCodeLength", "number", title: "Pin code length", description: "Number of digits in user code (4 to 10)", range: "4..10", defaultValue: DEFAULT_CODE_LENGTH, displayDuringSetup: false
        input "pinCodeTimeout", "number", title: "Pin entry timeout (s)", description: "Code reset timeout", range: "1..30", defaultValue: DEFAULT_CODE_TIMEOUT, displayDuringSetup: false
        input "autoLockTimeout", "decimal", title: "Auto lock delay (seconds)", defaultValue: defaultAutoLockTime, range: "1..*", required: false, displayDuringSetup: false
        //input "motionTimeout", "decimal", title: "Motion inactivity timeout (seconds)", defaultValue: defaultInactivityTimeout, range: "1..*", displayDuringSetup: false
        input "lockAction", "enum", title: "Arm mode when locked", description: "Select the keypad armed mode when 'locked'", options: ["armedStay": "Armed Stay", "armedAway": "Armed Away"], defaultValue: "armedAway", displayDuringSetup: false
        
        section() {
            input title: "", description: "", type: "paragraph", element: "paragraph", displayDuringSetup: true
            input title: "", description: "Ring Keypad Options", type: "paragraph", element: "paragraph", displayDuringSetup: true
            input "ringDirectArm", "bool", title: "Allow arming without a code", description: "Allow direct arming", defaultValue: "false", displayDuringSetup: false
            input "ringAnnouncementVolume", "number", title: "Announcement volume", description: "0 to 10", range: "0..10", defaultValue: 7, displayDuringSetup: false
            //input "ringSirenVolume", "number", title: "Siren volume", description: "0 to 10", range: "0..10", defaultValue: 10, displayDuringSetup: false
            input "ringSpecialLongPressDuration", "number", title: "Emergency buttons press duration (s)", description: "How long to press buttons to trigger alarm (2 to 5)", range: "2..5", defaultValue: 3, displayDuringSetup: false
            input "ringAmbientLightSensor", "number", title: "Ambient light sensor sensitivity (%)", description: "Ambinet light level at which to disable keypad lights (0 to 100)", range: "0..100", defaultValue: 20, displayDuringSetup: false
            input "ringProximitySensorDisable", "bool", title: "Disable proximity sensor", description: "Turn off proximity sensor", defaultValue: false, displayDuringSetup: false
            input "ringChime", "enum", title: "Chime tone", description: "Select the default chime sound to play", options: ringChimeOptions, defaultValue: "SOUND_5", displayDuringSetup: false
        }
    }

    tiles(scale: 2) {
        multiAttributeTile(name: "summary", type:"generic", width:6, height:4) {
            tileAttribute ("device.armMode", key: "PRIMARY_CONTROL") {            		
                attributeState "disarmed", label:'', icon:"https://www.rboyapps.com/images/Disarmed.png", backgroundColor:"#ffffff", defaultState: true
                attributeState "armedStay", label:'', icon:"https://www.rboyapps.com/images/ArmedStay.png", backgroundColor:"#ffffff"
                attributeState "armedAway", label:'', icon:"https://www.rboyapps.com/images/ArmedAway.png", backgroundColor:"#ffffff"
                attributeState "armedNight", label:'', icon:"https://www.rboyapps.com/images/ArmedStay.png", backgroundColor:"#ffffff"
            }
			tileAttribute("device.battery", key: "SECONDARY_CONTROL") {
				attributeState("default", label:'Battery: ${currentValue}%', unit:"%")
			}
        }
		standardTile("mode", "device.armMode", decoration: "flat", width: 2, height: 2) {
            state "disarmed", label:'', icon:"https://www.rboyapps.com/images/Disarmed.png", backgroundColor:"#ffffff", defaultState: true
            state "armedStay", label:'', icon:"https://www.rboyapps.com/images/ArmedStay.png", backgroundColor:"#ffffff"
            state "armedAway", label:'', icon:"https://www.rboyapps.com/images/ArmedAway.png", backgroundColor:"#ffffff"
            state "armedNight", label:'', icon:"https://www.rboyapps.com/images/ArmedStay.png", backgroundColor:"#ffffff"
        }
        standardTile("lock", "device.lock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
            state "locked", label:'locked', action:"lock.unlock", icon:"st.locks.lock.locked", backgroundColor:"#00a0dc", nextState:"unlocking"
            state "unlocked", label:'unlocked', action:"lock.lock", icon:"st.locks.lock.unlocked", backgroundColor:"#ffffff", nextState:"locking"
            state "unknown", label:"unknown", action:"lock.lock", icon:"st.locks.lock.unknown", backgroundColor:"#e86d13", nextState:"locking", defaultState: true
            state "locking", label:'locking', icon:"st.locks.lock.locked", backgroundColor:"#00a0dc"
            state "unlocking", label:'unlocking', icon:"st.locks.lock.unlocked", backgroundColor:"#ffffff"
		}
		valueTile("temperature", "device.temperature", width: 2, height: 2) {
			state("temperature", label:'${currentValue}Â°',
                  backgroundColors:[
                      // Celsius
                      [value: 0, color: "#153591"],
                      [value: 7, color: "#1e9cbb"],
                      [value: 15, color: "#90d2a7"],
                      [value: 23, color: "#44b621"],
                      [value: 28, color: "#f1d801"],
                      [value: 35, color: "#d04e00"],
                      [value: 37, color: "#bc2323"],
                      // Fahrenheit
                      [value: 40, color: "#153591"],
                      [value: 44, color: "#1e9cbb"],
                      [value: 59, color: "#90d2a7"],
                      [value: 74, color: "#44b621"],
                      [value: 84, color: "#f1d801"],
                      [value: 95, color: "#d04e00"],
                      [value: 96, color: "#bc2323"]
                  ]
			)
		}
		valueTile("battery", "device.battery", width: 2, height: 2, inactiveLabel: false) {
            state "battery", label:'${currentValue}%', unit: "", icon: "https://smartthings.rboyapps.com/images/battery.png", backgroundColors:[
                [value: 15, color: "#ff0000"],
                [value: 30, color: "#fd4e3a"],
                [value: 50, color: "#fda63a"],
                [value: 60, color: "#fdeb3a"],
                [value: 75, color: "#d4fd3a"],
                [value: 90, color: "#7cfd3a"],
                [value: 99, color: "#55fd3a"]
            ]
        }
        standardTile("motion", "device.motion", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
            state "active", label:'motion', icon:"st.motion.motion.active", backgroundColor:"#00a0dc"
            state "inactive", label:'no motion', icon:"st.motion.motion.inactive", backgroundColor:"#ffffff", defaultState: true
        }
		standardTile("tamper", "device.tamper", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "clear", label:'', backgroundColor:"#FFFFFF", defaultState: true
			state "detected", label:'TAMPER', backgroundColor:"#e86d13"
		}
        standardTile("panic", "device.button", decoration: "flat", width: 2, height: 2) {
            state "", label: '', icon:"", backgroundColor: "#ffffff", defaultState: true
            state "held", label: 'Panic', icon:"st.security.alarm.alarm", backgroundColor:"#e86d13", action: "clearPanic"
        }
        standardTile("alarm", "device.alarm", decoration: "flat", width: 2, height: 2) {
            state "", label: '', icon: "", backgroundColor: "#ffffff", defaultState: true
            state "off", label: 'Alarm', icon: "st.alarm.alarm.alarm", backgroundColor: "#ffffff", action: "alarm.both"
            state "both", label: 'Alarm', icon:"st.security.alarm.alarm", backgroundColor:"#e86d13", action: "alarm.off"
            state "siren", label: 'Alarm', icon:"st.security.alarm.alarm", backgroundColor:"#e86d13", action: "alarm.off"
            state "strobe", label: 'Alarm', icon:"st.security.alarm.alarm", backgroundColor:"#e86d13", action: "alarm.off"
        }
        standardTile("beep", "device.beep", decoration: "flat", width: 2, height: 2) {
            state "default", label: "Locate/beep", action:"tone.beep", icon:"st.quirky.spotter.quirky-spotter-sound-on", backgroundColor:"#ffffff"
        }
        standardTile("refresh", "device.refresh", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
            state "default", action:"refresh.refresh", icon:"st.secondary.refresh"
        }
        standardTile("configure", "device.configure", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
            state "default", action:"configuration.configure", icon:"st.secondary.configure"
        }
        valueTile("armMode", "device.armMode", decoration: "flat", width: 2, height: 2) {
            state "armMode", label: '${currentValue}'
        }
        standardTile("keypad", "device.keypad", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
            state "unknown", label:'', icon:"", backgroundColor:"#ffffff", nextState:"working", defaultState: true
            state "enabled", label:'Code Entry On', action:"disableKeypad", icon:"st.unknown.zwave.remote-controller", backgroundColor:"#ffffff", nextState:"working"
            state "disabled", label:'Code Off', action:"enableKeypad", icon:"st.unknown.zwave.remote-controller", backgroundColor:"#00a0dc", nextState:"working"
            state "working", label:'...', icon:"st.unknown.zwave.remote-controller", backgroundColor:"#cccccc"
        }
        standardTile("autolock", "device.autolock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
            state "unknown", label:'', icon:"", backgroundColor:"#ffffff", nextState:"working", defaultState: true
            state "enabled", label:'AutoLock', action:"disableAutolock", icon:"st.contact.contact.closed", backgroundColor:"#00a0dc", nextState:"working"
            state "disabled", label:'AutoLock Off', action:"enableAutolock", icon:"st.contact.contact.closed", nextState:"working"
            state "working", label:'...', icon:"st.contact.contact.closed", backgroundColor:"#cccccc"
        }
        valueTile("blank2x", "device.refresh", decoration: "flat", width: 2, height: 2) {
            state "", label: ''
        }
        if (!separateDevices) {
            childDeviceTiles("rich-control") // Render then all together
            /*[ "Police", "Fire", "Medical" ].each {
                childDeviceTile([childTileName: "rich-control"], "button${it}", "button${it}")
            }*/
        }

        main (["lock"])
        details (["mode", "lock", "autolock", "keypad", "beep", "alarm", "battery", "panic", "refresh"])
    }
}

import physicalgraph.zwave.commands.doorlockv1.*
import physicalgraph.zwave.commands.usercodev1.*
import groovy.transform.Field

private getSeparateDevices() { false } // Do we setup separate devices for the button sensor
private getRingChimeOptions() { [ "SOUND_1":"Navi", "SOUND_2":"Guitar", "SOUND_3":"Windchimes", "SOUND_4":"Ding dong neu", "SOUND_5":"Ring (default)" ] }

@Field final String COMMAND_CLASS_ENTRY_CONTROL = "6F"
@Field final String ENTRY_CONTROL_CONFIGURATION_GET = "07"
@Field final String ENTRY_CONTROL_CONFIGURATION_REPORT = "08"
@Field final String ENTRY_CONTROL_CONFIGURATION_SET = "06"
@Field final String ENTRY_CONTROL_EVENT_SUPPORTED_GET = "04"
@Field final String ENTRY_CONTROL_EVENT_SUPPORTED_REPORT = "05"
@Field final String ENTRY_CONTROL_KEY_SUPPORTED_GET = "02"
@Field final String ENTRY_CONTROL_KEY_SUPPORTED_REPORT = "03"
@Field final String ENTRY_CONTROL_NOTIFICATION = "01"

@Field final String COMMAND_CLASS_INDICATOR = "87"
@Field final String INDICATOR_GET = "02"
@Field final String INDICATOR_REPORT = "03"
@Field final String INDICATOR_SET = "01"
@Field final String INDICATOR_SUPPORTED_GET = "04"
@Field final String INDICATOR_SUPPORTED_REPORT = "05"

@Field final int DEFAULT_CODE_TIMEOUT = 10
@Field final int DEFAULT_MIN_CACHE_SIZE = 4
@Field final int DEFAULT_MAX_CACHE_SIZE = 10
@Field final int DEFAULT_RETRIES = 1 // Default retries from keypad
@Field final int DEFAULT_RETRIES_INTERVAL = 5 // Default retry interval from keypad
@Field final int DEFAULT_CODE_LENGTH = 4

@Field final def ENTRY_CONTROL_EVENT_TYPE = [
    0x00: "CACHING",
    0x01: "CACHED_KEYS",
    0x02: "ENTER",
    0x03: "DISARM_ALL",
    0x04: "ARM_ALL",
    0x05: "ARM_AWAY",
    0x06: "ARM_HOME",
    0x07: "EXIT_DELAY",
    0x08: "ARM_1",
    0x09: "ARM_2",
    0x0A: "ARM_3",
    0x0B: "ARM_4",
    0x0C: "ARM_5",
    0x0D: "ARM_6",
    0x0E: "RFID",
    0x0F: "BELL",
    0x10: "FIRE",
    0x11: "POLICE",
    0x12: "ALERT_PANIC",
    0x13: "ALERT_MEDICAL",
    0x14: "GATE_OPEN",
    0x15: "GATE_CLOSE",
    0x16: "LOCK",
    0x17: "UNLOCK",
    0x18: "TEST",
    0x19: "CANCEL",
]

@Field final def INDICATOR_PROPERTY_ID = [
    0x00: "RESERVED",
    0x01: "MULTILEVEL",
    0x02: "BINARY",
    0x03: "TOGGLING_PERIOD",
    0x04: "TOGGLING_CYCLES",
    0x05: "TOGGLING_ONTIME_PERIOD",
    0x06: "TIMEOUT_M",
    0x07: "TIMEOUT_S",
    0x08: "TIMEOUT_MS",
    0x09: "MULTILEVEL_SOUND",
    0x10: "ADVERTISE_LOW_POWER",
]

@Field final def INDICATOR_ID = [
        0x00: "RESERVED",
        0x02: "DISARMED",
        0x03: "READY",
        0x09: "INVALID_CODE",
        0x0A: "ARMED_STAY",
        0x0B: "ARMED_AWAY",
        0x0C: "ALARMING",
        0x0D: "ALARMING_BURGLAR",
        0x0E: "ALARMING_FIRE",
        0x0F: "ALARMING_CO",
        0x10: "BYPASS",
        0x11: "ENTRY_DELAY",
        0x12: "EXIT_DELAY",
        0x13: "ALARMING_MEDICAL",
        0x50: "IDENTIFY",
        0x60: "SOUND_1",
        0x61: "SOUND_2",
        0x62: "SOUND_3",
        0x63: "SOUND_4",
        0x64: "SOUND_5",
    ]

private getINDICATOR_ID_BY_NAME() { INDICATOR_ID.collectEntries { e -> [(e.value): e.key] } }
private getINDICATOR_PROPERTY_ID_BY_NAME() { INDICATOR_PROPERTY_ID.collectEntries { e -> [(e.value): e.key] } }
private getENTRY_CONTROL_EVENT_TYPE_BY_NAME() { ENTRY_CONTROL_EVENT_TYPE.collectEntries { e -> [(e.value): e.key] } }

private COMMAND_CLASS_INDICATOR_SET(listMap) { COMMAND_CLASS_INDICATOR + INDICATOR_SET + HexData(0) + HexData(listMap.size()) + listMap.collect { HexData(INDICATOR_ID_BY_NAME[it.indicatorId]) + HexData(INDICATOR_PROPERTY_ID_BY_NAME[it.propertyId]) + HexData(it.value) }?.join("") }
private COMMAND_CLASS_INDICATOR_GET(map) { COMMAND_CLASS_INDICATOR + INDICATOR_GET + HexData(INDICATOR_ID_BY_NAME[map.indicatorId]) }

private HexData(x) { String.format("%02X", x) }

private getMaxUsers() { 999 } // Maximum number of user codes supported
private getDefaultBeepLength() { 1 } // Default number of beeps
private getDefaultInactivityTimeout() { 10 } // Default motion inactive timeout
private getDefaultTempOffset() { 0 } // Default temperature offset
private getDefaultAutoLockTime() { 30 } // Default autolock timeout
private getPANIC_RESET_TIMEOUT() { 60 } // Timeout in seconds to reset panic state (not alarm)
private getPANEL_STATUS_ALARMED() { 7 }
private getPANEL_STATUS_DISARMED() { 0 }
private getPANEL_STATUS_ENTRY_DELAY() { 5 }
private getPANEL_STATUS_EXIT_DELAY() { 10 }
private getPIN_CODE_LENGTH() { pinCodeLength ?: DEFAULT_CODE_LENGTH }
private getPIN_CODE_TIMEOUT() { pinCodeTimeout ?: DEFAULT_CODE_TIMEOUT }

private identifyKeypadModel() {
    //log.trace "Identifying specific keypad model from database of known models"

    switch (state.MSR) { // check if we have a supported device
        case "0346-0101-0301":
            log.debug "Found Ring Alarm Keypad (Gen-2)"
            break
        default:
            log.warn "Unrecognized device. Contact developer with MSR $state.MSR"
	        break
    }
}

private getCommandClassVersions() {
    [
        0x70: 2, // Configuration
        0x71: 3, // Notification
        0x72: 2, // MSR
        0x80: 1, // Battery
        0x85: 2, // Association
        0x86: 1, // Version
        0x8A: 1, // Time
        0x98: 1, // Security
    ]
}

/**
* Called on app installed
*/
def installed() {
    state.userCodes = [:]
    
    schedule("* 0 */12 * * ?", scheduledPoll) // Poll every 12 hours

    try {
        // Device-Watch pings if no device events received for 6 hour (checkInterval)
        sendEvent(name:"powerSource", value: "mains") // The power sources has to be mains while pairing it
        sendEvent(name: "checkInterval", value: 6 * 60 * 60, displayed: false, data: [protocol: "zwave", hubHardwareId: device.hub.hardwareID, offlinePingable: "1"])
        sendEvent(name: "keypad", value: "enabled", descriptionText: "Keypad") // Initialize default
        sendEvent(name: "autolock", value: "disabled", descriptionText: "Auto lock") // Initialize default
        sendEvent(name: "lockCodes", value: util.toJson([:]), displayed: false, descriptionText: "'lockCodes' attribute updated")
        sendEvent(name: "alarm", value: "off", descriptionText: "Initializing alarm")
        sendEvent(name: "lock", value: "unlocked", descriptionText: "Initializing keypad")
        sendEvent(name: "armMode", value: "disarmed")
        sendEvent(name: "supportedArmModes", value: ["disarmed", "armedStay", "armedAway", "exitDelay", "entryDelay"].encodeAsJson(), descriptionText: "Initializing Arm modes")
        createChildDevices()
    } catch (e) {
        log.warn "installed() threw $e"
    }
}

/**
* Called on app uninstalled
*/
def uninstalled() {
    def deviceName = device.displayName
    log.trace "[DTH] Executing 'uninstalled()' for device $deviceName"
    sendEvent(name: "lockRemoved", value: device.id, isStateChange: true, displayed: false)
}

/**
* Executed when the user taps on the 'Done' button on the device settings screen. Sends the values to keypad.
*
* @return hubAction: The commands to be executed
*/
def updated() {
    log.trace "Updated called settings: $settings"

    def hubAction = null
    
    if (!state.lastUpdated || secondsPast(state.lastUpdated, 5)) { // Prevent a duplicate updated from being called
    	state.lastUpdated = now()
        try {
            def cmds = []

            schedule("* 0 */12 * * ?", scheduledPoll) // Poll every 12 hours

            // Device-Watch pings if no device events received for 6 hour (checkInterval)
            sendEvent(name: "checkInterval", value: 6 * 60 * 60, displayed: false, data: [protocol: "zwave", hubHardwareId: device.hub.hardwareID, offlinePingable: "1"])
            
            // Reset things which cannot be polled / updated manually
            resetCodeEntered()
            resetSmoke()
            resetTamper()
            resetPanic()

            cmds << doConfigure()
            cmds << refresh()

            hubAction = response(delayBetween(cmds.findAll{it}, 4200)) // Remove all empty/null
        } catch (e) {
            log.warn "updated() threw $e"
        }
	}
    
    hubAction
}

/**
 * Configures the device to settings needed by SmarthThings at device discovery time
 *
 */
def configure() {
	log.trace "[DTH] Executing 'configure()' for device ${device.displayName}"
	def cmds = doConfigure()
	//log.debug "Configure returning with commands := $cmds"
	cmds
}

/**
 * Returns the list of commands to be executed when the device is being configured/paired
 *
 */
def doConfigure() {
	log.trace "[DTH] Executing 'doConfigure()' for device ${device.displayName}"
	state.configured = true
    runIn(60, refresh)
	def cmds = []
    cmds << COMMAND_CLASS_ENTRY_CONTROL + ENTRY_CONTROL_CONFIGURATION_SET + HexData(PIN_CODE_LENGTH) + HexData(PIN_CODE_TIMEOUT) // Set the code length and entry timeout
    cmds << COMMAND_CLASS_ENTRY_CONTROL + ENTRY_CONTROL_CONFIGURATION_GET // Read the code length and entry timeout to report
    cmds << COMMAND_CLASS_ENTRY_CONTROL + ENTRY_CONTROL_EVENT_SUPPORTED_GET // Required to get cache size for pin code reports
    cmds << configureKeypad() // Configure keypad settings
    cmds << zwave.manufacturerSpecificV2.manufacturerSpecificGet().format()
	cmds << getBatteryState()
    cmds << getCodeLength()
	cmds = delayBetween(cmds.findAll{it}, 1200) // Remove the empty/null
    
	//log.debug "Do configure returning with commands := $cmds"
	cmds
}

/**
 * Responsible for parsing incoming device messages to generate events
 *
 * @param description: The incoming description from the device
 *
 * @return result: The list of events to be sent out
 *
 */
def parse(String description) {
	//log.trace "[DTH] Executing 'parse(String description)' for device ${device.displayName} with description = $description"
    
	def result = null
	if (description.startsWith("Err")) {
		if (state.sec) {
			result = createEvent(descriptionText:description, isStateChange:true, displayed:false)
		} else {
			result = createEvent(
					descriptionText: "This device failed to complete the network security key exchange. If you are unable to control it via SmartThings, you must remove it from your network and add it again.",
					eventType: "ALERT",
					name: "secureInclusion",
					value: "failed",
					displayed: true,
					)
		}
	} else {
        def cmdP = description?.tokenize(',')*.tokenize(':')?.collectEntries{ key, value -> [ (key.trim()): value.trim() ] }
        if (cmdP?.command?.startsWith(COMMAND_CLASS_ENTRY_CONTROL)) {
            result = zwaveEventEntryControl(cmdP)
        } else if (cmdP?.command?.startsWith(COMMAND_CLASS_INDICATOR)) {
            result = zwaveEventIndicator(cmdP)
        } else {
            def cmd = zwave.parse(description, commandClassVersions)
            if (cmd) {
                result = zwaveEvent(cmd)
            }
        }
	}
    sendEvent([name: "codeVersion", value: clientVersion()]) // Save client version for parent app
    sendEvent([name: "dhName", value: "Z-Wave Keypad Device Handler"]) // Save DH Name for parent app
	log.info "[DTH] parse() - returning result=$result"
	result
}

/**
 * Responsible for parsing SecurityMessageEncapsulation command
 *
 * @param cmd: The SecurityMessageEncapsulation command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityMessageEncapsulation cmd) {
	//log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityMessageEncapsulation)' with cmd = $cmd"
	def encapsulatedCommand = cmd.encapsulatedCommand(commandClassVersions)
	if (encapsulatedCommand) {
        //log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityMessageEncapsulation)' with encapsulated cmd = $encapsulatedCommand"
		zwaveEvent(encapsulatedCommand)
	} else {
        log.error "Error processing encapsulated $cmd"
    }
}

/**
 * Responsible for parsing NetworkKeyVerify command
 *
 * @param cmd: The NetworkKeyVerify command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.securityv1.NetworkKeyVerify cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.securityv1.NetworkKeyVerify)' with cmd = $cmd"
	createEvent(name:"secureInclusion", value:"success", descriptionText:"Secure inclusion was successful", isStateChange: true)
}

/**
 * Responsible for parsing SecurityCommandsSupportedReport command
 *
 * @param cmd: The SecurityCommandsSupportedReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityCommandsSupportedReport cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityCommandsSupportedReport)' with cmd = $cmd"
	state.sec = cmd.commandClassSupport.collect { String.format("%02X ", it) }.join()
	if (cmd.commandClassControl) {
		state.secCon = cmd.commandClassControl.collect { String.format("%02X ", it) }.join()
	}
	createEvent(name:"secureInclusion", value:"success", descriptionText:"Device is securely included", isStateChange: true)
}

/**
 * Responsible for parsing NotificationReport command
 *
 * @param cmd: The NotificationReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.notificationv3.NotificationReport cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.notificationv3.NotificationReport)' with cmd = $cmd"
	def result = []
	
	if (cmd.notificationType == 7) {
		result = handleBurglarNotificationReport(cmd)
	} else if(cmd.notificationType == 8) {
		result = handleBatteryNotificationReport(cmd)
	} else if(cmd.notificationType == 9) {
		result = handleSystemNotificationReport(cmd)
	} else {
		result = handleNotificationReportUsingAlarmType(cmd)
	}
		
	result = result ?: null
	log.debug "[DTH] zwaveEvent(physicalgraph.zwave.commands.alarmv2.AlarmReport) returning with result = $result"
	result
}

/**
 * Responsible for handling Burglar NotificationReport command
 *
 * @param cmd: The NotificationReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
private def handleBurglarNotificationReport(cmd) {
	log.trace "[DTH] Executing 'handleBurglarNotificationReport' with cmd = $cmd"
	def result = []
	def deviceName = device.displayName
	
	def map = [:]
	switch (cmd.event) {
		case 0x00:
			map.descriptionText = "Dropped frame notifications disabled"
			break
		case 0xFF:
			map.descriptionText = "Dropped frame notifications enabled"
			break
		default:
			// delegating it to handleNotificationReportUsingAlarmType
			return handleNotificationReportUsingAlarmType(cmd)
	}
	
	result << createEvent(map)
	result
}

/**
 * Responsible for handling System NotificationReport command
 *
 * @param cmd: The NotificationReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
private def handleSystemNotificationReport(cmd) {
	log.trace "[DTH] Executing 'handleSystemNotificationReport' with cmd = $cmd"
	def result = []
	def deviceName = device.displayName
	
	def map = [:]
	switch (cmd.event) {
		case 4: // Software failure
        	switch (cmd.eventParameter?.first()) {
                case 0x55:
                    map = [ descriptionText: "Keypad watchdog failure", displayed: true, data: [ lockName: deviceName ] ]
                    break
                case 0xA9:
                    map = [ descriptionText: "Z-Wave SDK fault", displayed: true, data: [ lockName: deviceName ] ]
                    break
                case 0xAB:
                    map = [ descriptionText: "Pin soft reset", displayed: true, data: [ lockName: deviceName ] ]
                    break
                case 0xAA:
                    map = [ descriptionText: "Ring keypad software fault", displayed: true, data: [ lockName: deviceName ] ]
                    break
                case 0xAC:
                    map = [ descriptionText: "Keypad software reset", displayed: true, data: [ lockName: deviceName ] ]
                    break
                case 0xAD:
                    map = [ descriptionText: "Keypad lost communication with hub", displayed: true, data: [ lockName: deviceName ] ]
                    break
                default:
                    map = [ descriptionText: "Keypad software error", displayed: true, data: [ lockName: deviceName ] ]
                    break
            }
            break
		default:
			// delegating it to handleNotificationReportUsingAlarmType
			return handleNotificationReportUsingAlarmType(cmd)
	}
	
	result << createEvent(map)
	result
}

/**
 * Responsible for handling Battery NotificationReport command
 *
 * @param cmd: The NotificationReport command to be parsed
 *
 * @return The event(s) to be sent out
 */
private def handleBatteryNotificationReport(cmd) {
	log.trace "[DTH] Executing 'handleBatteryNotificationReport' with cmd = $cmd"
	def result = []
	def deviceName = device.displayName
	def map = [ name: "powerSource", value: "battery" ] // default is battery
	switch(cmd.event) {
        case 0x01: // power has been applied, check if the battery level updated
        	map = [ descriptionText: "Powering up", displayed: true ]
            result << response(getBatteryState())
            break
        case 0x02: // A/C mains disconnected
        	map = [ name: "powerSource", value: "battery", descriptionText: "AC mains disconnected" ]
            result << response(getBatteryState())
            break
        case 0x03: // A/C mains re-connected, check if the battery level updated
            map = [ name: "powerSource", value: "mains", descriptionText: "AC mains reconnected" ]
            break
        case 0x05: // Voltage drop/drift
        	map = [ descriptionText: "Brownout detected", displayed: true  ]
            break
        case 0x09: // Load error
        	map = [ descriptionText: "Motor load error", data: [ lockName: deviceName ]  ]
            break
        case 0x0C: // Battery charging
        	map = [ descriptionText: "Battery is charging", displayed: true, data: [ lockName: deviceName ] ]
            break
        case 0x0D:
        	map = [ descriptionText: "Battery is fully charged", displayed: true, data: [ lockName: deviceName ] ]
	        break
        case 0x0A: // Replace battery soon
        case 0x0E: // Charge battery soon
			map = [ name: "battery", value: 1, descriptionText: "Battery level critical", displayed: true, data: [ lockName: deviceName ] ]
			break
		case 0x0B: // Replace battery now
        case 0x0F: // Charge battery now
			map = [ name: "battery", value: 0, descriptionText: "Battery too low to operate keypad", isStateChange: true, displayed: true, data: [ lockName: deviceName ] ]
			break
		default:
			// delegating it to handleNotificationReportUsingAlarmType
			return handleNotificationReportUsingAlarmType(cmd)
	}
	result << createEvent(map)
	result
}

/**
 * Responsible for handling NotificationReport commands which are ignored by others
 *
 * @param cmd: The NotificationReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
private def handleNotificationReportUsingAlarmType(cmd) {
	log.trace "[DTH] Executing 'handleNotificationReportUsingAlarmType' with cmd = $cmd"
	def result = []
	def map = null
	def deviceName = device.displayName
	switch(cmd.v1AlarmType) {
		default:
			map = [ displayed: false, descriptionText: "V1 alarm type ${cmd.v1AlarmType} level ${cmd.v1AlarmLevel}" ]
			break
	}
	
	if (map) {
		if (map.data) {
			map.data.lockName = deviceName
		} else {
			map.data = [ lockName: deviceName ]
		}
		result << createEvent(map)
	}
	result = result.flatten()
	result
}

/**
 * Responsible for parsing AssociationReport command
 *
 * @param cmd: The AssociationReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.associationv2.AssociationReport cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.associationv2.AssociationReport)' with cmd = $cmd"
	def result = []
	if (cmd.nodeId.any { it == zwaveHubNodeId }) {
		state.remove("associationQuery")
		state["associationQuery"] = null
		result << createEvent(descriptionText: "Is associated")
		state.assoc = zwaveHubNodeId
	} else if (cmd.groupingIdentifier == 1) {
		result << response(secure(zwave.associationV1.associationSet(groupingIdentifier:1, nodeId:zwaveHubNodeId)))
	} else if (cmd.groupingIdentifier == 2) {
		result << response(zwave.associationV1.associationSet(groupingIdentifier:2, nodeId:zwaveHubNodeId))
	}
	result
}

/**
 * Responsible for parsing TimeGet command
 *
 * @param cmd: The TimeGet command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.timev1.TimeGet cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.timev1.TimeGet)' with cmd = $cmd"
	def result = []
	def now = new Date().toCalendar()
	if(location.timeZone) now.timeZone = location.timeZone
	result << createEvent(descriptionText: "Requested time update", displayed: false)
	result << response(secure(zwave.timeV1.timeReport(
		hourLocalTime: now.get(Calendar.HOUR_OF_DAY),
		minuteLocalTime: now.get(Calendar.MINUTE),
		secondLocalTime: now.get(Calendar.SECOND)))
	)
	result
}

/**
 * Responsible for parsing BatteryReport command
 *
 * @param cmd: The BatteryReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.batteryv1.BatteryReport cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.batteryv1.BatteryReport)' with cmd = $cmd"
	def map = [ name: "battery", unit: "%" ]
	if (cmd.batteryLevel == 0xFF) {
		map.value = 1
		map.descriptionText = "Has a low battery"
	} else {
		map.value = cmd.batteryLevel
		map.descriptionText = "Battery is at ${cmd.batteryLevel}%"
	}
	state.lastbatt = now()
	log.info "Battery level $map.value%"
	createEvent(map) 
}

/**
 * Responsible for parsing ManufacturerSpecificReport command
 *
 * @param cmd: The ManufacturerSpecificReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.manufacturerspecificv2.ManufacturerSpecificReport cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.manufacturerspecificv2.ManufacturerSpecificReport)' with cmd = $cmd"
	def result = []
	def msr = String.format("%04X-%04X-%04X", cmd.manufacturerId, cmd.productTypeId, cmd.productId)
	updateDataValue("MSR", msr)
	result << createEvent(descriptionText: "MSR: $msr", isStateChange: false)
	result
}

/**
 * Responsible for parsing VersionReport command
 *
 * @param cmd: The VersionReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.versionv1.VersionReport cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.versionv1.VersionReport)' with cmd = $cmd"
	def fw = "${cmd.applicationVersion}.${cmd.applicationSubVersion}"
	updateDataValue("fw", fw)
	if (getDataValue("MSR") == "003B-6341-5044") {
		updateDataValue("ver", "${cmd.applicationVersion >> 4}.${cmd.applicationVersion & 0xF}")
	}
	def text = "${device.displayName}: firmware version: $fw, Z-Wave version: ${cmd.zWaveProtocolVersion}.${cmd.zWaveProtocolSubVersion}"
	createEvent(descriptionText: text, isStateChange: false)
}

/**
 * Responsible for parsing ApplicationBusy command
 *
 * @param cmd: The ApplicationBusy command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.applicationstatusv1.ApplicationBusy cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.applicationstatusv1.ApplicationBusy)' with cmd = $cmd"
	def msg = cmd.status == 0 ? "try again later" :
			  cmd.status == 1 ? "try again in ${cmd.waitTime} seconds" :
			  cmd.status == 2 ? "request queued" : "sorry"
	createEvent(displayed: true, descriptionText: "Is busy, $msg")
}

/**
 * Responsible for parsing ApplicationRejectedRequest command
 *
 * @param cmd: The ApplicationRejectedRequest command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.applicationstatusv1.ApplicationRejectedRequest cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.applicationstatusv1.ApplicationRejectedRequest)' with cmd = $cmd"
	createEvent(displayed: true, descriptionText: "Rejected the last request")
}

/**
 * Responsible for parsing zwave command
 *
 * @param cmd: The zwave command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.Command cmd) {
	log.warn "Ignoring command from $device.displayName: ${cmd.inspect()}"
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.Command)' with cmd = $cmd"
	createEvent(displayed: false, descriptionText: "$cmd")
}

// Handles Indicator Class
def zwaveEventIndicator(cmd) {
    log.trace "Processing Indicator command class: $cmd"
    
    def command = cmd.command?.drop(2) // First 2 are for COMMAND_CLASS_INDICATOR, next 2 are the command
    def data = cmd.payload?.split(" ").collect { Integer.parseInt(it, 16) }
    
    def results = []
    
    switch (command) {
        case INDICATOR_SUPPORTED_REPORT: // [zw device:70, command:8705, payload:00 03 02 00 00]
            def indicatorID = "0x" + String.format("%02X", data[0]) + " (${INDICATOR_ID[data[0]] ?: "<unknown>"})"
            data = data.drop(1)
            def nextIndicatorID = data[0]
            data = data.drop(1)
            def propertyBitMaskLength = data[0] & 0x1F
            data = data.drop(1)
            def propertyIDs = []
            (propertyBitMaskLength ? 1..propertyBitMaskLength : null).each {
                def bitMask = data[0]
                data = data.drop(1)
                (0..7).each { bit ->
                    if ((bitMask & (1 << bit)) >> bit) {
                        propertyIDs << INDICATOR_PROPERTY_ID[((it-1)*8 + bit)] // This is the event type
                    }
                }
            }

            log.debug "INDICATOR_SUPPORTED_REPORT: Indicator ID: ${indicatorID}, Next Indicator ID: 0x${String.format("%02X", nextIndicatorID)}, Supported Properties: ${propertyIDs}"
            if (nextIndicatorID) { // Get the next indicator details
                results << response(COMMAND_CLASS_INDICATOR + INDICATOR_SUPPORTED_GET + HexData(nextIndicatorID))
            }
            break            

        case INDICATOR_REPORT: // [zw device:70, command:8703, payload:00]
            def indicator0Value = data[0]
            data = data.drop(1)
            def indicatorProperties
            if (data.size() > 0) {
                def indicatorObjects = data[0] & 0x1F
                data = data.drop(1)
                indicatorProperties = (indicatorObjects ? 1..indicatorObjects : null).collect {
                    def indicatorID = data[0]
                    data = data.drop(1)
                    def propertyID = data[0]
                    data = data.drop(1)
                    def value = data[0]
                    data = data.drop(1)
                    switch (INDICATOR_ID[indicatorID]) {
                        case "DISARMED":
                        	if ((INDICATOR_PROPERTY_ID[propertyID] == "MULTILEVEL") && value) {
                                results << createEvent(name: "armMode", value: "disarmed")
                            }
                        	break
                        case "ARMED_STAY":
                        	if ((INDICATOR_PROPERTY_ID[propertyID] == "MULTILEVEL") && value) {
                                results << createEvent(name: "armMode", value: "armedStay")
                            }
                        	break
                        case "ARMED_AWAY":
                        	if ((INDICATOR_PROPERTY_ID[propertyID] == "MULTILEVEL") && value) {
                                results << createEvent(name: "armMode", value: "armedAway")
                            }
                        	break
                        case "EXIT_DELAY":
                        	if ((INDICATOR_PROPERTY_ID[propertyID] == "TIMEOUT_M") && value) {
                                results << createEvent(name: "armMode", value: "exitDelay")
                            }
                        	break
                        case "ENTRY_DELAY":
                        	if ((INDICATOR_PROPERTY_ID[propertyID] == "TIMEOUT_M") && value) {
                                results << createEvent(name: "armMode", value: "entryDelay")
                            }
                        	break
                    }
                    [
                        "Indicator": INDICATOR_ID[indicatorID] ?: "0x" + String.format("%02X", indicatorID),
                        "Property": INDICATOR_PROPERTY_ID[propertyID] ?: "0x" + String.format("%02X", propertyID),
                        "Value": "0x" + String.format("%02X", value),
                    ]
                }
            }
            log.debug "INDICATOR_REPORT: Indicator0Value: ${indicator0Value}, Other Indicators: ${indicatorProperties}" 
            break            

        default:
        	log.warn "Unknown COMMAND_CLASS_INDICATOR command: ${command}, payload ${cmd.payload}"
            break
    }    
    
    results
}

// Handles Entry Control Command Class responses
def zwaveEventEntryControl(cmd) {
    log.trace "Processing Entry Control command class: $cmd"
    
    def command = cmd.command?.drop(2) // First 2 are for COMMAND_CLASS_ENTRY_CONTROL, next 2 are the command
    def data = cmd.payload?.split(" ").collect { Integer.parseInt(it, 16) }
    
    def results = []
    
    switch (command) {
        case ENTRY_CONTROL_CONFIGURATION_REPORT: // [zw device:70, command:6F08, payload:04 02]
            def keyCacheSize = data[0]
            def keyCacheTimeout = data[1]
            results << createEvent([name: "codeLength", value: keyCacheSize, descriptionText: "User code length is ${keyCacheSize} digits"])
            results << createEvent([name: "codeTimeout", value: keyCacheTimeout, descriptionText: "Code time out is ${keyCacheTimeout} seconds"])
            log.debug "ENTRY_CONTROL_CONFIGURATION_REPORT: Pin code length: ${keyCacheSize}, Timeout: ${keyCacheTimeout}"
            
            break
            
        case ENTRY_CONTROL_EVENT_SUPPORTED_REPORT: // [zw device:70, command:6F05, payload:01 04 04 6F 00 0F 02 04 0A 01 1E]
            def dataTypeCount = data[0] // Event data types
            data = data.drop(1)
            (dataTypeCount ? 1..dataTypeCount : null).each {
                def dataType = data[0] & 0x3 // First 2 bits only
                data = data.drop(1)
                switch (dataType) {
                    case 0x00:
                        log.trace "NA: No data included"
                        break                
                    case 0x01:
                        log.trace "RAW: 1 to 32 bytes of binary data"
                        break
                    case 0x02:
                        log.trace "ASCII: 1 to 32 ASCII encoded characters (0x00 - 0xF7)"
                        break
                    case 0x03:
                        log.trace "MD5: 16 byte binary data encoded as MD5"
                        break
                    default:
                        log.error "Unknown Event data type: ${dataType}"
                        break
                }
            }
            
            def eventSupportCount = data[0] // Event types
            data = data.drop(1)
            def supportedTypes = []
            (eventSupportCount ? 1..eventSupportCount : null).each {
                def keySupported = data[0]
                data = data.drop(1)
                (0..7).each { bit ->
                    if ((keySupported & (1 << bit)) >> bit) {
                        supportedTypes << ENTRY_CONTROL_EVENT_TYPE[((it-1)*8 + bit)] // This is the event type
                    }
                }
            }
            
            def keyCacheSizeMin = data[0] // Key cached size supported minimum
            data = data.drop(1)
            def keyCacheSizeMax = data[0] // Key cached size supported maximum
            data = data.drop(1)
            def keyCacheTimeMin = data[0] // Key cached timeout supported minimum
            data = data.drop(1)
            def keyCacheTimeMax = data[0] // Key cached timeout supported minimum
            data = data.drop(1)

            results << createEvent([name: "minCacheSize", value: keyCacheSizeMin, descriptionText: "Minimum pin size is ${keyCacheSizeMin} digits", displayed: false])
            results << createEvent([name: "maxCacheSize", value: keyCacheSizeMax, descriptionText: "Maximum pin size is ${keyCacheSizeMax} digits", displayed: false])

        	log.debug "ENTRY_CONTROL_EVENT_SUPPORTED_REPORT: Event types supported: ${supportedTypes}, Pin code length min/max: ${keyCacheSizeMin}/${keyCacheSizeMax}, Pin code timeout min/max: ${keyCacheTimeMin}/${keyCacheTimeMax}"
            break
            
        case ENTRY_CONTROL_KEY_SUPPORTED_REPORT: // [zw device:70, command:6F03, payload:0A 00 00 00 00 00 00 FF 03 FF 03]
            def keySupportedCount = data[0] // Key supported types
            data = data.drop(1)
            def supportedTypes = ""
            (keySupportedCount ? 1..keySupportedCount : null).each {
                def keySupported = data[0]
                data = data.drop(1)
                (0..7).each { bit ->
                    if ((keySupported & (1 << bit)) >> bit) {
                        supportedTypes += (((it-1)*8 + bit) as char) // This ASCII is supported
                    }
                }
            }

        	log.debug "ENTRY_CONTROL_KEY_SUPPORTED_REPORT: Keys supported : ${supportedTypes}"
            break
            
        case ENTRY_CONTROL_NOTIFICATION: // [zw device:70, command:6F01, payload:00 02 00 00] [zw device:70, command:6F01, payload:01 02 01 04 31 31 31 31] [zw device:70, command:6F01, payload:02 02 03 00]
            if (state.lastControlNotificationSequence == data[0]) { // Sequence (don't process duplicates)
                log.warn "Dropping duplicate ENTRY_CONTROL_NOTIFICATION, seq no: 0x${String.format("%02X", data[0])}"
                return []
            }
            state.lastControlNotificationSequence = data[0] // Save the last sequence
            data = data.drop(1)
            def dataType = data[0] & 0x3 // First 2 bits only
            data = data.drop(1)
            switch (dataType) {
                case 0x00:
                    log.trace "NA: No data included"
                    break                
                case 0x01:
                    log.error "Unsupported RAW: 1 to 32 bytes of binary data"
                    break
                case 0x02:
                    //log.trace "ASCII: 1 to 32 ASCII encoded characters (0x00 - 0xF7)"
                    break
                case 0x03:
                    log.error "Unsupported MD5: 16 byte binary data encoded as MD5"
                    break
                default:
                    log.error "Unknown Notification data type: ${dataType}"
	                break
            }

            def eventType = data[0] // Event type
            data = data.drop(1)
            def eventDataCount = data[0] // Event data
            data = data.drop(1)
            def eventData = (eventDataCount ? 1..eventDataCount : null).collect {
                def eData = data[0]
                data = data.drop(1)
                return eData as char
            }?.join("")
            
        	def seconds = ((device.currentValue("codeTimeout") ?: DEFAULT_CODE_TIMEOUT) + (DEFAULT_RETRIES_INTERVAL * DEFAULT_RETRIES)) as Integer
            
            switch (ENTRY_CONTROL_EVENT_TYPE[eventType]) { // Handle event data based on type
                case "CACHING":
                	//resetCodeEntered() // Start a new code - This may come out of order, so don't reset there
                    break
                case "CACHED_KEYS":
                    sendEvent(name: "lastPin", value: eventData) // Save it, pin and mode come separately and not always in the same order
                    if (device.currentValue("lastMode")) {
                        results << createCodeEntryEvent(eventData, reverseArmModeMap[device.currentValue("lastMode")])
                        resetCodeEntered() // Start a new code
                    } else {
                        log.trace "Resetting code in ${seconds} seconds"
                        runIn(seconds, resetCodeEntered, [overwrite: true]) // If we don't get a response we reset the last code and account for retries
                    }
                    break
                case "ENTER":
                    resetCodeEntered()
                    break
                case "DISARM_ALL":
                    sendEvent(name: "lastMode", value: "disarmed")
                    if (device.currentValue("lastPin")) { // No direct disarming
                        results << createCodeEntryEvent(device.currentValue("lastPin"), reverseArmModeMap["disarmed"])
                        resetCodeEntered() // Start a new code
                    } else {
                        log.trace "Resetting code in ${seconds} seconds"
                        runIn(seconds, resetCodeEntered, [overwrite: true]) // If we don't get a response we reset the last code and account for retries
                    }
                    break
                case "ARM_AWAY":
                    sendEvent(name: "lastMode", value: "armedAway")
                    if (device.currentValue("lastPin") || (isRingKeypad() ? ringDirectArm : false)) { // Check for direct arming
                        results << createCodeEntryEvent(device.currentValue("lastPin"), reverseArmModeMap["armedAway"])
                        resetCodeEntered() // Start a new code
                    } else {
                        log.trace "Resetting code in ${seconds} seconds"
                        runIn(seconds, resetCodeEntered, [overwrite: true]) // If we don't get a response we reset the last code and account for retries
                    }
                    break
                case "ARM_HOME":
                    sendEvent(name: "lastMode", value: "armedStay")
                    if (device.currentValue("lastPin") || (isRingKeypad() ? ringDirectArm : false)) { // Check for direct arming
                        results << createCodeEntryEvent(device.currentValue("lastPin"), reverseArmModeMap["armedStay"])
                        resetCodeEntered() // Start a new code
                    } else {
                        log.trace "Resetting code in ${seconds} seconds"
                        runIn(seconds, resetCodeEntered, [overwrite: true]) // If we don't get a response we reset the last code and account for retries
                    }
                    break
                case "FIRE":
                    resetCodeEntered()
                    results << fireAlarm()
                    break
                case "POLICE":
                    resetCodeEntered()
                    results << policeAlarm()
                    break
                case "ALERT_PANIC":
                    resetCodeEntered()
                    results << panicAlarm()
                    break
                case "ALERT_MEDICAL":
                    resetCodeEntered()
                    results << medicalAlarm()
                    break
                case "CANCEL":
                    resetCodeEntered()
                    break
                default:
                    resetCodeEntered()
                    log.error "Unsupported Notification event type: 0x${String.format("%02X", eventType)}"
                    break
            }

            log.debug "ENTRY_CONTROL_NOTIFICATION: ${ENTRY_CONTROL_EVENT_TYPE[eventType]}${ENTRY_CONTROL_EVENT_TYPE[eventType] == "CACHED_KEYS" ? ", Pin: ${eventData}" : ""}"
            break
            
        default:
        	log.warn "Unknown COMMAND_CLASS_ENTRY_CONTROL command: ${command}, payload ${cmd.payload}"
            break
    }    
    
    //log.warn results.flatten()
    results.flatten()
}


/**
 * Executes lock and then check command with a delay on a lock
 */
def lockAndCheck(doorLockMode) {
	lock()
}

/**
 * PING is used by Device-Watch in attempt to reach the Device
 */
def ping() {
	log.trace "[DTH] Executing ping() for device ${device.displayName}"
	COMMAND_CLASS_ENTRY_CONTROL + ENTRY_CONTROL_CONFIGURATION_GET // Read pin length/timeout
}

// Reset the pin entered
def resetCodeEntered() {
    log.trace "Resetting last code"
    sendEvent(name: "lastMode", value: "")
    sendEvent(name: "lastPin", value: "")
    unschedule("resetCodeEntered") // If there are any pending, drop them
}

private getArmModeMap() {
    [
        "0": "disarmed",
        "1": "armedStay",
        "2": "armedNight",
        "3": "armedAway",
        //"${PANEL_STATUS_EXIT_DELAY}": "exitDelay",
        //"${PANEL_STATUS_ENTRY_DELAY}": "entryDelay",
    ]
}

private getReverseArmModeMap() {
    [
        "disarmed": 0,
        "armedStay": 1,
        "armedNight": 2,
        "armedAway": 3,
        //"exitDelay": PANEL_STATUS_EXIT_DELAY,
        //"entryDelay": PANEL_STATUS_ENTRY_DELAY,
    ]
}

// Used by SHM Delay to disable logging of invalid pins since the app tracks user pins
def disableInvalidPinLogging(disable) {
    if (disable) {
        log.debug "Disabling invalid user pin logging"
        state.disableInvalidPinLogEntry = true
    } else {
        log.debug "Enabling invalid user pin logging"
        state.disableInvalidPinLogEntry = false
    }
}

// KEYPAD MOTION EVENTS
def setMotion(evt = null) {
    log.trace "Setting motion to ${evt?.value}"
    sendEvent(name: "motion", value: evt?.value)
    
    if (evt?.value == "active") {
        // Calculate Inactive timeout value
        def motionTimeRun = ((motionTimeout as Integer) >= 0) ? (motionTimeout as Integer) : defaultInactivityTimeout

        // If Inactive timeout was configured
        log.debug "Motion Active, deactivating in $motionTimeRun seconds"
        if (motionTimeRun > 0) {
            runIn(motionTimeRun, setMotion, [overwrite: true, data: [value: "inactive"]]) // If something was pending, overwrite it
        } else {
            sendEvent(name: "motion", value: "inactive")
        }
    }
}

// ALARM COMMANDS
def off() {
	log.info "Turning off alarm"
    sendEvent(name: "alarm", value: "off")
    response(setDisarmed())
}

def strobe() {
	log.info "Turning on strobe"
    sendEvent(name: "alarm", value: "strobe")
    def cmds = [
        COMMAND_CLASS_INDICATOR_SET([ [indicatorId: "ALARMING", propertyId: "MULTILEVEL_SOUND", value: 0] ]),
        //COMMAND_CLASS_INDICATOR_GET(indicatorId: "ALARMING"),
    ]
    response(cmds)    
}

def siren() {
	log.info "Turning on siren"
    sendEvent(name: "alarm", value: "siren")
    def cmds = [
        COMMAND_CLASS_INDICATOR_SET([ [indicatorId: "ALARMING", propertyId: "MULTILEVEL_SOUND", value: 100] ]),
        //COMMAND_CLASS_INDICATOR_GET(indicatorId: "ALARMING"),
    ]
    response(cmds)    
}

def both() {
	log.info "Turning on strobe and siren"    
    sendEvent(name: "alarm", value: "both")
    def cmds = [
        COMMAND_CLASS_INDICATOR_SET([ [indicatorId: "ALARMING", propertyId: "MULTILEVEL_SOUND", value: 100] ]),
        //COMMAND_CLASS_INDICATOR_GET(indicatorId: "ALARMING"),
    ]
    response(cmds)    
}

// KEYPAD ALARM BUTTON TRIGGERS
// Button 1
private policeAlarm() {
    log.info "Police alarm triggered"
    sendEvent(name: "button", value: "held", data: [buttonNumber: 1], descriptionText: "$device.displayName Police alarm button was pushed", isStateChange: true)
    def childDev = childDevices?.find { dev -> dev.deviceNetworkId?.contains("Police") }
    childDev?.sendEvent(name: "button", value: "held", data: [buttonNumber: 1], descriptionText: "$device.displayName Police alarm button was pushed", isStateChange: true)
    sendEvent(name: "alarm", value: "both")
    runIn(PANIC_RESET_TIMEOUT, resetPanic)
    def cmds = [
        COMMAND_CLASS_INDICATOR_SET([ [indicatorId: "ALARMING_BURGLAR", propertyId: "MULTILEVEL_SOUND", value: 100] ]),
        //COMMAND_CLASS_INDICATOR_GET(indicatorId: "ALARMING_BURGLAR"),
    ]
    response(cmds)
}

// Button 2
private fireAlarm() {
    // TODO: Should we report smoke capability here?
    log.info "Fire alarm triggered"
    sendEvent(name: "button", value: "held", data: [buttonNumber: 2], descriptionText: "$device.displayName Fire alarm button was pushed", isStateChange: true)
    def childDev = childDevices?.find { dev -> dev.deviceNetworkId?.contains("Fire") }
    childDev?.sendEvent(name: "button", value: "held", data: [buttonNumber: 1], descriptionText: "$device.displayName Fire alarm button was pushed", isStateChange: true)
    sendEvent(name: "alarm", value: "both")
    runIn(PANIC_RESET_TIMEOUT, resetPanic)
    def cmds = [
        COMMAND_CLASS_INDICATOR_SET([ [indicatorId: "ALARMING_FIRE", propertyId: "MULTILEVEL_SOUND", value: 100] ]),
        //COMMAND_CLASS_INDICATOR_GET(indicatorId: "ALARMING_FIRE"),
    ]
    response(cmds)
}

// Button 3
private medicalAlarm() {
    log.info "Medical alarm triggered"
    sendEvent(name: "button", value: "held", data: [buttonNumber: 3], descriptionText: "$device.displayName Medical alarm button was pushed", isStateChange: true)
    def childDev = childDevices?.find { dev -> dev.deviceNetworkId?.contains("Medical") }
    childDev?.sendEvent(name: "button", value: "held", data: [buttonNumber: 1], descriptionText: "$device.displayName Medical alarm button was pushed", isStateChange: true)
    sendEvent(name: "alarm", value: isRingKeypad() ? "strobe" : "both") // Ring only displays the flashing light
    runIn(PANIC_RESET_TIMEOUT, resetPanic)
    def cmds = [
        COMMAND_CLASS_INDICATOR_SET([ [indicatorId: "ALARMING_MEDICAL", propertyId: "MULTILEVEL_SOUND", value: 100] ]),
        //COMMAND_CLASS_INDICATOR_GET(indicatorId: "ALARMING_MEDICAL"),
    ]
    response(cmds)
}

// Button 4
private panicAlarm() {
    log.info "Panic alarm triggered"
    sendEvent(name: "button", value: "held", data: [buttonNumber: 4], descriptionText: "$device.displayName Panic alarm button was pushed", isStateChange: true)
    def childDev = childDevices?.find { dev -> dev.deviceNetworkId?.contains("Panic") }
    childDev?.sendEvent(name: "button", value: "held", data: [buttonNumber: 1], descriptionText: "$device.displayName Panic alarm button was pushed", isStateChange: true)
    sendEvent(name: "alarm", value: "both")
    runIn(PANIC_RESET_TIMEOUT, resetPanic)
    def cmds = [
        COMMAND_CLASS_INDICATOR_SET([ [indicatorId: "ALARMING", propertyId: "MULTILEVEL_SOUND", value: 100] ]),
        //COMMAND_CLASS_INDICATOR_GET(indicatorId: "ALARMING"),
    ]
    response(cmds)
}

def resetPanic() {
    log.trace "Resetting Panic Button state"
    childDevices?.each { dev -> dev.sendEvent(name: "button", value: "") }
    sendEvent(name: "button", value: "", displayed: false) // No need to show reset
}

def clearPanic() {
    log.trace "Clearing Panic state"
    resetPanic()
    off() // Turn off alarm if supported
}

// KEYPAD SECURITY STATES
def setArmMode(armMode) {
    log.info "Setting arm mode to: ${armMode}"
    
    switch (armMode) {
        case "disarmed":
        	setDisarmed()
            break
        case "armedAway":
        	setArmedAway()
            break
        case "armedStay":
        	setArmedStay()
            break
        case "armedNight":
        	setArmedNight()
            break
        default:
        	log.error "Invalid arm mode: ${armMode}"
            break
    }
}

// Disarm keypad
def setDisarmed(lockEvent = true) {
	log.info "Disarming keypad"
    if (lockEvent) {
        sendEvent(name: "lock", value: "unlocked", data: [ method: "command", armMode: "disarmed" ], descriptionText: "Unlocked by disarm")
    }
    def cmds = [
        COMMAND_CLASS_INDICATOR_SET([ [indicatorId: "DISARMED", propertyId: "MULTILEVEL", value: 100] ]),
        COMMAND_CLASS_INDICATOR_GET(indicatorId: "DISARMED"),
    ]
    cmds
}

// Armed Away keypad
def setArmedAway(lockEvent = true) {
	log.info "Arming away keypad"
    if (lockEvent) {
        sendEvent(name: "lock", value: "locked", data: [ method: "command", armMode: "armedAway" ], descriptionText: "Locked by arm away")
    }
    def cmds = [
        COMMAND_CLASS_INDICATOR_SET([ [indicatorId: "ARMED_AWAY", propertyId: "MULTILEVEL", value: 100] ]),
        COMMAND_CLASS_INDICATOR_GET(indicatorId: "ARMED_AWAY"),
    ]
    cmds
}

// Armed Stay keypad
def setArmedStay(lockEvent = true) {
	log.info "Arming away keypad"
    if (lockEvent) {
        sendEvent(name: "lock", value: "locked", data: [ method: "command", armMode: "armedStay" ], descriptionText: "Locked by arm stay")
    }
    def cmds = [
        COMMAND_CLASS_INDICATOR_SET([ [indicatorId: "ARMED_STAY", propertyId: "MULTILEVEL", value: 100] ]),
        COMMAND_CLASS_INDICATOR_GET(indicatorId: "ARMED_STAY"),
    ]
    cmds
}

// Arm Night (legacy apps)
def setArmedNight(lockEvent = true) {
    log.warn "Keypad does not support this"
}

// Set entry delay in seconds
def setEntryDelay(delay) {
    log.info "Starting entry delay for $delay seconds"
    if (delay <= 0) {
        log.error "Invalid entry delay: $delay"
        return
    }

    def min = (delay/60) as int
    def sec = (delay % 60)
    def cmds = [
        COMMAND_CLASS_INDICATOR_SET([ [indicatorId: "ENTRY_DELAY", propertyId: "TIMEOUT_M", value: min], [ indicatorId: "ENTRY_DELAY", propertyId: "TIMEOUT_S", value: sec] ]),
        COMMAND_CLASS_INDICATOR_GET(indicatorId: "ENTRY_DELAY"),
    ]
    cmds
}

// Set exit delay in seconds
def setExitDelay(delay) {
    log.info "Starting exit delay for $delay seconds"
    if (delay <= 0) {
        log.error "Invalid exit delay: $delay"
        return
    }

    def min = (delay/60) as int
    def sec = (delay % 60)
    def cmds = [
        COMMAND_CLASS_INDICATOR_SET([ [indicatorId: "EXIT_DELAY", propertyId: "TIMEOUT_M", value: min], [ indicatorId: "ENTRY_DELAY", propertyId: "TIMEOUT_S", value: sec] ]),
        COMMAND_CLASS_INDICATOR_GET(indicatorId: "EXIT_DELAY"),
    ]
    cmds
}

// Sends new or current Arm Mode to keypad
private sendStatusToDevice(newArmMode = null) {
	def armMode = newArmMode ?: device.currentValue("armMode") ?: "disarmed" // null or empty armModes are disarmed
	log.trace "Sending status to device, Arm mode: $armMode"

    def cmds = []
    switch (armMode) {
        case "disarmed":
        	cmds << setDisarmed(false) // only updating status, don't need to send lock event
        	break
        case "armedStay":
        	cmds << setArmedStay(false) // only updating status, don't need to send lock event
        	break
        case "armedAway":
        	cmds << setArmedAway(false) // only updating status, don't need to send lock event
        	break
        default:
	        log.error "Unknown armMode: $armMode"
        	break
    }
	
    //sendHubCommand(response(cmds.flatten()).toHubAction())
    cmds.flatten()
}

// Locate keypad
def beep(def beepLen = (beepLength as Integer)) {
    beepLen = beepLen ?: defaultBeepLength // take care of null's

    if (beepLen > 0xFE) { // Maximum 254 times
        beepLen = 0xFE
    }
    
    log.info "Beeping ${beepLen} times"

    def cmd = COMMAND_CLASS_INDICATOR_SET([
        //[indicatorId: "IDENTIFY", propertyId: "TOGGLING_PERIOD", value: 10], // For 1 second
        //[indicatorId: "IDENTIFY", propertyId: "TOGGLING_CYCLES", value: beepLen], // For beepLen times
        [indicatorId: (isRingKeypad() ? (ringChime ?: "SOUND_5") : "SOUND_5"), propertyId: "MULTILEVEL_SOUND", value: 255],
    ])
    cmd
}

// Legacy apps
def acknowledgeArmRequest(armMode) {
    log.info "Sending acknowledge arm notification"
    //sendStatusToDevice(armModeMap[armMode as String])
    def cmd = COMMAND_CLASS_INDICATOR_SET([ [indicatorId: "READY", propertyId: "MULTILEVEL", value: 100] ])
    cmd
}

// Returns a command for an invalid code sound response
def sendInvalidKeycodeResponse() {
    log.info "Sending invalid key code notification"
    def cmd = COMMAND_CLASS_INDICATOR_SET([ [indicatorId: "INVALID_CODE", propertyId: "MULTILEVEL_SOUND", value: 100] ])
    cmd
}

private createCodeEntryEvent(keycode, armMode) {
    def results = []
    def cmds = []
    def map = null
    
    if (device.currentValue("keypad") == "disabled") {
        log.warn "Keypad disabled, not processing code entry $keycode"
        map = [ name: "invalidCode", value: "detected", descriptionText: "${armMode ? "Lock" : "Unlock"} code ${keycode ?: ""} entered while keypad was disabled", isStateChange: true, displayed: true ]
    } else {
        try {
            // SHM Delay after platform update
            if (state.disableInvalidPinLogEntry) {
                results << createEvent(name: "codeEntered", value: ((keycode ?: "0000") + '/' + (armMode as String)), isStateChange: true, displayed: false) // Fix for iL02_1 not reporting code for arming
            } else { // Legacy apps
                results << createEvent(name: "codeEntered", value: (keycode ?: "0000") as String, data: armMode as String, isStateChange: true, displayed: false) // Fix for iL02_1 not reporting code for arming
            }
        } catch (Exception e) {
            log.error "Error sending codeEntered report: $e"
        }
        // Lock handler
        def codeID = findUserID(keycode)
        def changeType, lockCodes, codeName
        def deviceName = device.displayName
        lockCodes = loadLockCodes()
        if (codeID != null) {
            map = [ name: "lock", value: (armMode ? "locked" : "unlocked"), isStateChange: true, displayed: true ] // Each time a valid code is entered activate the actions (unlike a regular lock)
            codeName = getCodeName(lockCodes, codeID)
            map.descriptionText = "${armMode ? "Locked" : "Unlocked"} by \"$codeName\""
            map.data = [ codeId: codeID as String, usedCode: codeID, codeName: codeName, method: "keypad", armMode: armModeMap[armMode as String] ]
            log.info "Keypad $map.value by $codeName in slot $codeID"
            cmds << sendStatusToDevice(armModeMap[armMode as String]) // Update keypad state
            if (!armMode) {
                autoRelock() // Auto relock if required
            }
        } else if (!keycode && armMode && (isRingKeypad() ? ringDirectArm : true)) { // Check if it allows you to arm/disarm without any codes, we should never allow disarming without a code
            map = [ name: "lock", value: (armMode ? "locked" : "unlocked"), isStateChange: true, displayed: true ] // Each time the mode is changed activate the actions (unlike a regular lock)
            map.descriptionText = "${armMode ? "Locked" : "Unlocked"}"
            map.data = [ method: "keypad", armMode: armModeMap[armMode as String] ]
            log.info "Keypad $map.value"
            cmds << sendStatusToDevice(armModeMap[armMode as String]) // Update keypad state
            if (!armMode) {
                autoRelock() // Auto relock if required
            }
        } else {
            map = [ name: "invalidCode", value: "detected", descriptionText: "Invalid ${armMode ? "lock" : "unlock"} code ${keycode ?: ""} entered", isStateChange: true, displayed: state.disableInvalidPinLogEntry ? false : true ]
            log.warn "Invalid code $keycode detected trying to ${armMode ? "lock" : "unlock"} keypad"
            cmds << sendInvalidKeycodeResponse() // Send invalid key code
        }
    }
    
    cmds ? [ *(results << createEvent(map)), response(delayBetween(cmds, 200)) ] : (results << createEvent(map))
}

// API COMMANDS
def setKeypad(mode) {
    log.trace "Set keypad mode to $mode"
    
    switch (mode) {
        case "enabled": // Bug with new ST app presentation, send attribute instead of command
        case "enable":
        	enableKeypad()
            break
        case "disabled": // Bug with new ST app presentation, send attribute instead of command
        case "disable":
        	disableKeypad()
            break
        default:
        	log.error "Invalid keypad mode: $mode"
            break
    }
}

def enableKeypad() {
    log.debug "Enabling keypad"
    sendEvent(name: "keypad", value: "enabled", descriptionText: "Keypad enabled")
}

def disableKeypad() {
    log.debug "Disabling keypad"
    sendEvent(name: "keypad", value: "disabled", descriptionText: "Keypad disabled")
}

def setAutolock(mode) {
    log.trace "Set autolock mode to $mode"
    
    switch (mode) {
        case "enabled": // Bug with new ST app presentation, send attribute instead of command
        case "enable":
        	enableAutolock()
            break
        case "disabled": // Bug with new ST app presentation, send attribute instead of command
        case "disable":
        	disableAutolock()
            break
        default:
        	log.error "Invalid autolock mode: $mode"
            break
    }
}

def enableAutolock() {
    log.debug "Enabling autolock with timeout ${(autoLockTimeout as Integer) ?: defaultAutoLockTime} seconds"
    sendEvent(name: "autolock", value: "enabled", descriptionText: "Auto lock set to ${(autoLockTimeout as Integer) ?: defaultAutoLockTime} seconds")
}

def disableAutolock() {
    log.debug "Disabling autolock"
    sendEvent(name: "autolock", value: "disabled", descriptionText: "Auto lock disabled")
    unschedule("lock") // Incase there was one pending
}

/**
 * Executes lock command on a keypad
 */
def lock(data = null) {
	log.trace "[DTH] Executing lock() for device ${device.displayName}${data?.method ? " with extended data ${data.inspect()}" : ""}"
	def map = [ name: "lock", value: "locked", descriptionText: "Locked" ]
    if (data?.method) {
        map.data = [ method: data?.method ]
    }
    sendEvent(map)
    if (device.currentValue("armMode") == "disarmed") { // If it's arleady in armed state then keep it
        sendHubCommand(response(lockAction == "armedStay" ? setArmedStay(false) : setArmedAway(false)).toHubAction()) // Lock state has already been sent
    }
}

/**
 * Executes unlock command on a keypad
 */
def unlock() {
	log.trace "[DTH] Executing unlock() for device ${device.displayName}"
	sendEvent(name: "lock", value: "unlocked", descriptionText: "Unlocked")
    autoRelock()
    if (device.currentValue("armMode") != "disarmed") { // If it's arleady in disarmed state then keep it
        sendHubCommand(response(setDisarmed()).toHubAction())
    }
}

private autoRelock() {
    if (device.currentValue("autolock") == "enabled") {
        def time = (autoLockTimeout as Integer) ?: defaultAutoLockTime
        log.trace "Auto lock enabled, locking in $time seconds"
        runIn(time, lock, [data: [method: "auto"]]) // relock
    }
}

/**
 * Called when the user taps on the refresh button
 */
def refresh() {
    log.debug "Refresh called, Device MSR is ${state.MSR}, FW is ${state.fw}\n$zwaveInfo"
    
    identifyKeypadModel()

    def cmds = []

    // Debug
    //cmds << zwave.indicatorV1.indicatorGet().format()
    //cmds << COMMAND_CLASS_INDICATOR + INDICATOR_SUPPORTED_GET + HexData(0) // Get the 0th Indicator to start the chain
    //cmds << COMMAND_CLASS_INDICATOR_GET(indicatorId: "DISARMED") // TODO: How do we read the current status of the keypad arm mode? This doesn't work, it always returns 0x64 (undefined) for DISARMED, ARMED_AWAY and ARMED_STAY with Ring keypads

    // Platform should automatically encapsulate this
    cmds << COMMAND_CLASS_ENTRY_CONTROL + ENTRY_CONTROL_EVENT_SUPPORTED_GET // Required to get cache size for pin code reports
    
    if (!device.currentValue("armMode")) { // Initialize it
        cmds << setDisarmed() // Start with disarmed
    }

    if (!state.MSR || !state.configured) { // If we don't have a MSR or we refreshed the settings, first get it
        log.debug "Getting Device MSR"
        cmds << zwave.manufacturerSpecificV2.manufacturerSpecificGet().format()
    }

    if (!state.configured) {
        cmds << configureKeypad() // Configure settings
        state.configured = true // We're done here
    }

	log.trace "Current user pin code length ${device.currentValue("codeLength")}"
    cmds << getCodeLength() // Pin code length, Check for changes
    cmds << getBatteryState() // Battery

    delayBetween(cmds.findAll{it}, 1200) // Remove all empty/null
}

def scheduledPoll() {
    sendHubCommand(response(poll()).toHubAction()) // Send command since this can be called from a schedule
}

/**
 * Called by the Smart Things platform in case Polling capability is added to the device type
 */
def poll() {
    log.debug "Poll called, Device MSR is $state.MSR"

    def cmds = []
    
    // Only check armMode state if it changed recently or we haven't had an update in an hour
    def latest = device.currentState("armMode")?.date?.time
    if (!latest || !state.lastPoll || !secondsPast(latest, 6 * 60) || secondsPast(state.lastPoll, 55 * 60)) {
        state.lastPoll = now()
    }
    
    if (!state.lastbatt || secondsPast(state.lastbatt, 24*60*60)) {
        cmds << getBatteryState()
        state.lastbatt = now()  //inside-214
    }
    
    if (cmds) {
        delayBetween(cmds.findAll{it}, 1200) // Remove all emtpy/null
    } else {
        // workaround to keep polling from stopping due to lack of activity
        log.trace "Poll called again to soon, skipping poll to save battery"
        sendEvent(descriptionText: "skipping poll", isStateChange: true, displayed: false)
        null
    }
}

/**
 * Returns the command for user code get
 *
 * @param codeID: The code slot number
 *
 * @return The command for user code get
 */
def requestCode(codeID) {
    return null
}

/**
 * API endpoint for server smart app to populate the attributes. Called only when the attributes are not populated.
 *
 * @return The command(s) fired for reading attributes
 */
def reloadAllCodes() {
	log.trace "[DTH] Executing 'reloadAllCodes()' by ${device.displayName}"
    
    return []
}

/**
 * API endpoint for setting the user code length on a keypad
 *
 * @param length: The user code length
 *
 * @returns The command for writing the code length attribute
 */
def setCodeLength(length) {
    length = length.toInteger()
    if (length >= (device.currentValue("minCacheSize") ?: DEFAULT_MIN_CACHE_SIZE) && length <= (device.currentValue("maxCacheSize") ?: DEFAULT_MAX_CACHE_SIZE)) {
        log.trace "[DTH] Executing 'setCodeLength()' by ${device.displayName}"
        return [
            COMMAND_CLASS_ENTRY_CONTROL + ENTRY_CONTROL_CONFIGURATION_SET + HexData(length) + HexData(device.currentValue("codeTimeout") ?: DEFAULT_CODE_TIMEOUT), // 4 digit codes with 5 second timeout
            COMMAND_CLASS_ENTRY_CONTROL + ENTRY_CONTROL_CONFIGURATION_GET,
        ]
    }

    return null
}

/**
 * API endpoint for getting the pin code length on a keypad.
 *
 * @returns The command fired for getting the code length attribute or if it isn't supported sets the value of attribute 'codeLength' to 0 and returns null
 */
def getCodeLength() {
    log.debug "Getting configured user pin code length"

    def cmds = []

    log.trace "Querying Ring keypad pin length"
    cmds << COMMAND_CLASS_ENTRY_CONTROL + ENTRY_CONTROL_CONFIGURATION_GET
    //sendEvent(name: "codeLength", value: 0) // Not supported

    cmds
}

// Reports that code was processed successfully
def reportCodeProcessed() {
    def result = state.pending
    log.trace "Sending code reports: ${result}"
    result?.each { sendEvent(it) }
    state.pending = [] // Clear it after we successfully send all events
}

/**
 * API endpoint for setting a user code on a keypad
 *
 * @param codeID: The code slot number
 *
 * @param code: The code PIN
 *
 * @param codeName: The name of the code
 *
 * @returns cmds: The commands for creation and checking of a keypad code
 */
def setCode(codeID, code, codeName = null) {
    def cmds = []
    
	if (!code) {
		log.trace "[DTH] Executing 'nameSlot()' by ${this.device.displayName}"
		nameSlot(codeID, codeName)
		return
	}

	cmds += validateAttributes().flatten()

    def result = setCodeGenerate(codeID, code, codeName)
    state.pending = ((state.pending ?: []) + result).flatten() // Save the list for processing since we may get multiple repeat calls
    runIn(1, reportCodeProcessed) // Delay sending the report as SmartLocks looks at timestamp and it should happen after the method ends

	if(cmds.size() > 1) {
		cmds = delayBetween(cmds, 200)
	}
	
    return cmds
}

// Internal function to return the events required to confirm setting a code
private setCodeGenerate(codeID, code, codeName = null) {
	log.trace "[DTH] Executing 'setCode()' for slot $codeID, name $codeName by ${this.device.displayName}"

	def strname = (codeName ?: "Code $codeID")
	state["setname$codeID"] = strname
	
	def result = []
	def map = null
	def changeType, lockCodes
	def deviceName = device.displayName

    state.userCodes["$codeID"] = code // Save the code for lookup

    lockCodes = loadLockCodes()
    changeType = getChangeType(lockCodes, codeID)
    map = [ name: "codeChanged", value: "$codeID $changeType",  descriptionText: "${getStatusForDescription(changeType)} \"$codeName\"", isStateChange: true ]
    map.data = [ codeName: codeName, notify: true, notificationText: "${getStatusForDescription(changeType)} \"$codeName\" in $deviceName at ${location.name}" ]
    if(!isMasterCode(codeID)) {
        result << codeSetEvent(lockCodes, codeID, codeName)
    } else {
        map.descriptionText = "${getStatusForDescription('set')} \"$codeName\""
        map.data.notificationText = "${getStatusForDescription('set')} \"$codeName\" in $deviceName at ${location.name}"
    }

    if (map.data) {
        map.data.lockName = deviceName
    } else {
        map.data = [ lockName: deviceName ]
    }
    result << createEvent(map)
    result = result.flatten()
    
    result
}

/**
 * Validates attributes and if attributes are not populated, adds the command maps to list of commands
 * @return List of commands or empty list
 */
def validateAttributes() {
	def cmds = []

	if(!device.currentValue("maxCodes")) {
        //sendEvent(name: "maxCodes", value: maxUsers, displayed: false)
        state.codes = maxUsers
        state.remove("checkCode")
        state["checkCode"] = null
	}
    
    if(!device.currentValue("codeLength")) {
		cmds << getCodeLength()
	}
	log.trace "validateAttributes returning commands list: " + cmds
	cmds
}

/**
 * API endpoint for setting/deleting multiple user codes on a keypad
 *
 * @param codeSettings: The map with code slot numbers and code pins (in case of update)
 *
 * @returns
 */
def updateCodes(codeSettings) {
	log.trace "[DTH] Executing updateCodes() for device ${device.displayName}"
	if(codeSettings instanceof String) codeSettings = util.parseJson(codeSettings)

    def result = []
    codeSettings.each { name, updated ->
		if (name.startsWith("code")) {
			def n = name[4..-1].toInteger()
			if (updated) { // Don't check code size here, leave it to the SmartApp as different locks have different limitations
				log.debug "Setting code number $n"
                result << setCodeGenerate(n, updated)
			} else if (updated == null || updated == "" || updated == "0") {
				log.debug "Deleting code number $n"
                result << deleteCodeGenerate(n)
			}
		} else log.warn("unexpected entry $name: $updated")
	}

    result = result.flatten()
    state.pending = ((state.pending ?: []) + result).flatten() // Save the list for processing since we may get multiple repeat calls
    runIn(1, reportCodeProcessed) // Delay sending the report as SmartLocks looks at timestamp and it should happen after the method ends

    return null
}

/**
 * Renames an existing lock slot
 *
 * @param codeSlot: The code slot number
 *
 * @param codeName The new name of the code
 */
void nameSlot(codeSlot, codeName) {
	codeSlot = codeSlot.toString()
	if (!isCodeSet(codeSlot)) {
		return
	}
	def deviceName = device.displayName
	log.trace "[DTH] - Executing nameSlot() for slot $codeSlot, name $codeName for device $deviceName"
	def lockCodes = loadLockCodes()
	def oldCodeName = getCodeName(lockCodes, codeSlot)
	def newCodeName = codeName ?: "Code $codeSlot"
	lockCodes[codeSlot] = newCodeName
	sendEvent(lockCodesEvent(lockCodes))
	sendEvent(name: "codeChanged", value: "$codeSlot renamed", data: [ lockName: deviceName, notify: false, notificationText: "Renamed \"$oldCodeName\" to \"$newCodeName\" in $deviceName at ${location.name}" ],
		descriptionText: "Renamed \"$oldCodeName\" to \"$newCodeName\"", displayed: true, isStateChange: true)
}

/**
 * API endpoint for deleting a user code on a keypad
 *
 * @param codeID: The code slot number
 *
 * @returns
 */
def deleteCode(codeID) {
    def result = deleteCodeGenerate(codeID)
    state.pending = ((state.pending ?: []) + result).flatten() // Save the list for processing since we may get multiple repeat calls
    runIn(1, reportCodeProcessed) // Delay sending the report as SmartLocks looks at timestamp and it should happen after the method ends

    return null
}

// Internal function to return the events required to confirm deleting a code
private def deleteCodeGenerate(codeID) {
	log.trace "[DTH] Executing 'deleteCode()' for slot $codeID by ${this.device.displayName}"

    state.userCodes["$codeID"] = null // Delete the code from lookup (remove doesn't work on state)
    
	def result = []
	def map = [ name: "codeChanged", isStateChange: true ]
	def changeType, lockCodes, codeName
	def deviceName = device.displayName
	lockCodes = loadLockCodes()
    if (lockCodes[codeID.toString()]) {
        codeName = getCodeName(lockCodes, codeID)
        map.value = "$codeID deleted"
        map.descriptionText = "Deleted \"$codeName\""
        map.data = [ codeName: codeName, lockName: deviceName, notify: true, notificationText: "Deleted \"$codeName\" in $deviceName at ${location.name}" ]
        result << codeDeletedEvent(lockCodes, codeID)
    } else {
        map.value = "$codeID unset"
        map.displayed = false
        map.data = [ lockName: deviceName ]
    }

    result << createEvent(map)
    result = result.flatten()
    
    result
}

/**
 * Encapsulates a command
 *
 * @param cmd: The command to be encapsulated
 *
 * @returns ret: The encapsulated command
 */
private secure(physicalgraph.zwave.Command cmd) {
	zwave.securityV1.securityMessageEncapsulation().encapsulate(cmd).format()
}

/**
 * Encapsulates list of command and adds a delay
 *
 * @param commands: The list of command to be encapsulated
 *
 * @param delay: The delay between commands
 *
 * @returns The encapsulated commands
 */
private secureSequence(commands, delay = 0) {
    if (delay) {
        return delayBetween(commands.collect{ secure(it) }, delay)
    } else {
        return commands.collect{ secure(it) }
    }
}

/**
 * Checks if the time elapsed from the provided timestamp is greater than the number of senconds provided
 *
 * @param timestamp: The timestamp
 *
 * @param seconds: The number of seconds
 *
 * @returns true if elapsed time is greater than number of seconds provided, else false
 */
private Boolean secondsPast(timestamp, seconds) {
	if (!(timestamp instanceof Number)) {
		if (timestamp instanceof Date) {
			timestamp = timestamp.time
		} else if ((timestamp instanceof String) && timestamp.isNumber()) {
			timestamp = timestamp.toLong()
		} else {
			return true
		}
	}
	return (now() - timestamp) > (seconds * 1000)
}

/**
 * Reads the code name from the 'lockCodes' map
 *
 * @param lockCodes: map with lock code names
 *
 * @param codeID: The code slot number
 *
 * @returns The code name
 */
private String getCodeName(lockCodes, codeID) {
	if (isMasterCode(codeID)) {
		return "Master Code"
	}
	lockCodes[codeID.toString()] ?: "Code $codeID"
}

/**
 * Reads the code name from the device state
 *
 * @param lockCodes: map with lock code names
 *
 * @param codeID: The code slot number
 *
 * @returns The code name
 */
private String getCodeNameFromState(lockCodes, codeID) {
	if (isMasterCode(codeID)) {
		return "Master Code"
	}
	def nameFromLockCodes = lockCodes[codeID.toString()]
	def nameFromState = state["setname$codeID"]
	if(nameFromLockCodes) {
		if(nameFromState) {
			//Updated from smart app
			return nameFromState
		} else {
			//Updated from lock
			return nameFromLockCodes
		}
	} else if(nameFromState) {
		//Set from smart app
		return nameFromState
	}
	//Set from lock
	return "Code $codeID"
}

/**
 * Check if a user code is present in the 'lockCodes' map
 *
 * @param codeID: The code slot number
 *
 * @returns true if code is present, else false
 */
private Boolean isCodeSet(codeID) {
	// BUG: Needed to add loadLockCodes to resolve null pointer?
	def lockCodes = loadLockCodes()
	lockCodes[codeID.toString()] ? true : false
}

/**
 * Reads the 'lockCodes' attribute and parses the same
 *
 * @returns Map: The lockCodes map
 */
private Map loadLockCodes() {
	parseJson(device.currentValue("lockCodes") ?: "{}") ?: [:]
}

/**
 * Populates the 'lockCodes' attribute by calling create event
 *
 * @param lockCodes The user codes in a lock
 */
private Map lockCodesEvent(lockCodes) {
	createEvent(name: "lockCodes", value: util.toJson(lockCodes), displayed: false,
	descriptionText: "'lockCodes' attribute updated")
}

/**
 * Utility function to figure out if code id pertains to master code or not
 *
 * @param codeID - The slot number in which code is set
 * @return - true if slot is for master code, false otherwise
 */
private boolean isMasterCode(codeID) {
	if(codeID instanceof String) {
		codeID = codeID.toInteger()
	}
	(codeID == 0) ? true : false
}

/**
 * Creates the event map for user code creation
 *
 * @param lockCodes: The user codes in a lock
 *
 * @param codeID: The code slot number
 *
 * @param codeName: The name of the user code
 *
 * @return The list of events to be sent out
 */
private def codeSetEvent(lockCodes, codeID, codeName) {
	clearStateForSlot(codeID)
	// codeID seems to be an int primitive type
	lockCodes[codeID.toString()] = (codeName ?: "Code $codeID")
	def result = []
	result << lockCodesEvent(lockCodes)
	def codeReportMap = [ name: "codeReport", value: codeID, data: [ code: "" ], isStateChange: true, displayed: false ]
	codeReportMap.descriptionText = "${device.displayName} code $codeID is set"
	result << createEvent(codeReportMap)
	result
}

/**
 * Creates the event map for user code deletion
 *
 * @param lockCodes: The user codes in a lock
 *
 * @param codeID: The code slot number
 *
 * @return The list of events to be sent out
 */
private def codeDeletedEvent(lockCodes, codeID) {
	lockCodes.remove("$codeID".toString())
	// not sure if the trigger has done this or not
	clearStateForSlot(codeID)
	def result = []
	result << lockCodesEvent(lockCodes)
	def codeReportMap = [ name: "codeReport", value: codeID, data: [ code: "" ], isStateChange: true, displayed: false ]
	codeReportMap.descriptionText = "${device.displayName} code $codeID was deleted"
	result << createEvent(codeReportMap)
	result
}

/**
 * Creates the event map for all user code deletion
 *
 * @return The List of events to be sent out
 */
private def allCodesDeletedEvent() {
	def result = []
	def lockCodes = loadLockCodes()
	def deviceName = device.displayName
	lockCodes.each { id, code ->
		result << createEvent(name: "codeReport", value: id, data: [ code: "" ], descriptionText: "code $id was deleted",
					displayed: false, isStateChange: true)
		
		def codeName = code
		result << createEvent(name: "codeChanged", value: "$id deleted", data: [ codeName: codeName, lockName: deviceName,
			notify: true, notificationText: "Deleted \"$codeName\" in $deviceName at ${location.name}" ],
		descriptionText: "Deleted \"$codeName\"",
		displayed: true, isStateChange: true)
		clearStateForSlot(id)
	}
	result
}

/**
 * Checks if a change type is set or update
 *
 * @param lockCodes: The user codes in a lock
 *
 * @param codeID The code slot number
 *
 * @return "set" or "update" basis the presence of the code id in the lockCodes map
 */
private def getChangeType(lockCodes, codeID) {
	def changeType = "set"
	if (lockCodes[codeID.toString()]) {
		changeType = "changed"
	}
	changeType
}

/**
 * Method to obtain status for descriptuion based on change type
 * @param changeType: Either "set" or "changed"
 * @return "Added" for "set", "Updated" for "changed", "" otherwise
 */
private def getStatusForDescription(changeType) {
	if("set" == changeType) {
		return "Added"
	} else if("changed" == changeType) {
		return "Updated"
	}
	//Don't return null as it cause trouble
	return ""
}

/**
 * Clears the code name and pin from the state basis the code slot number
 *
 * @param codeID: The code slot number
 */
def clearStateForSlot(codeID) {
	state.remove("setname$codeID")
	state["setname$codeID"] = null
}

/**
 * Find the corresponding slot for a code
 *
 * @param code: The code
 * @return codeID or null if not found
 */
private findUserID(code) {
    //log.trace "User Codes: ${state.userCodes?.inspect()}"
    def id = state.userCodes.find { key, value ->
        value == code ? true : false
    }
    
    return id?.key as Integer
}

// CUSTOM STUFF
/**
 * Responsible for parsing ConfigurationReport command
 *
 * @param cmd: The ConfigurationReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.configurationv2.ConfigurationReport cmd) { // Even though you're using V1 to read, ST seems to report it using V2 format, so process as V2
    log.trace "ConfigurationReport $cmd"
    def map = []

    if (isRingKeypad()) {
        map << ringConfigurationReport(cmd)
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown keypad. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
    }

    //log.info map
    return map.flatten()
}

// Parse Ring keypad parameters
private ringConfigurationReport(cmd) {
    //log.trace "Processing Ring Configuration Report"
    def map = null

    switch (cmd.parameterNumber) {
        case ringParamMap.ringRetries.Param:
        	map = [ displayed: false, descriptionText: "$device.displayName: Retry count ${cmd.scaledConfigurationValue}" ]
        	break
        case ringParamMap.ringRetryInterval.Param:
        	map = [ displayed: false, descriptionText: "$device.displayName: Retry interval ${cmd.scaledConfigurationValue} seconds" ]
        	break
        case ringParamMap.ringAnnouncementVolume.Param:
        	map = [ displayed: false, descriptionText: "$device.displayName: Annoucement volume ${cmd.scaledConfigurationValue}" ]
        	break
        case ringParamMap.ringKeyToneVolume.Param:
        	map = [ displayed: false, descriptionText: "$device.displayName: Key tone volume ${cmd.scaledConfigurationValue}" ]
        	break
        case ringParamMap.ringSirenVolume.Param:
        	map = [ displayed: false, descriptionText: "$device.displayName: Siren volume ${cmd.scaledConfigurationValue}" ]
        	break
        case ringParamMap.ringSpecialLongPressDuration.Param:
        	map = [ displayed: false, descriptionText: "$device.displayName: Special (emergency) keys long duration press ${cmd.scaledConfigurationValue} seconds" ]
        	break
        case ringParamMap.ringLongPressDuration.Param:
        	map = [ displayed: false, descriptionText: "$device.displayName: Regular keys long duration press ${cmd.scaledConfigurationValue} seconds" ]
        	break
        case ringParamMap.ringAmbientLightSensor.Param:
        	map = [ displayed: false, descriptionText: "$device.displayName: Ambient light sensor threshold ${cmd.scaledConfigurationValue}%" ]
        	break
        case ringParamMap.ringProximitySensor.Param:
        	map = [ displayed: false, descriptionText: "$device.displayName: Proximity sensor ${cmd.scaledConfigurationValue ? "enabled" : "disabled"}" ]
        	break
        default:
            map = [ displayed: false, descriptionText: "$device.displayName: Parameter $cmd.parameterNumber configuration $cmd.configurationValue" ]
            break
    }

    return createEvent(map)
}

/**
 * Getting the battery state
 *
 * @returns The command fired for getting the battery state on a keypad
 */
private getBatteryState() {
    // Some keypad implement non secure reading of battery
    def security = true

    security ? secure(zwave.batteryV1.batteryGet()) : zwave.batteryV1.batteryGet().format()
}

/**
 * Configuring the parameters
 *
 * @returns The command fired for sending the configuration settings to the keypad or null if it's an unsupported keypad
 */
private configureKeypad() {
    log.trace "$device.displayName: Configuring settings"
    def map = null
    
    if (isRingKeypad()) { // Ring keypad
        map = configureRing()
    } else {
        log.warn "Unsupported device with MSR $state.MSR"
    }

    return map
}

private configureRing() {
    log.trace "Configure Ring keypad settings"
    def cmds = []
    
    sendEvent(name: "supportedArmModes", value: ["disarmed", "armedStay", "armedAway", "exitDelay", "entryDelay"].encodeAsJson(), descriptionText: "Initializing Arm modes", displayed: false)

    [ "ringAnnouncementVolume", "ringSpecialLongPressDuration", "ringAmbientLightSensor" ].each { keypadSetting -> // "ringSirenVolume" - not working
        if (settings."${keypadSetting}" != null) {
            cmds << zwave.configurationV1.configurationSet(parameterNumber: ringParamMap."${keypadSetting}".Param, size: ringParamMap."${keypadSetting}".Size, configurationValue: getRingParamMap(settings."${keypadSetting}")."${keypadSetting}".ParamValue)
            cmds << zwave.configurationV1.configurationGet(parameterNumber: ringParamMap."${keypadSetting}".Param)
        } else {
            cmds << zwave.configurationV1.configurationSet(parameterNumber: ringParamMap."${keypadSetting}".Param, size: ringParamMap."${keypadSetting}".Size, defaultValue: true)
            cmds << zwave.configurationV1.configurationGet(parameterNumber: ringParamMap."${keypadSetting}".Param)
        }
    }
    
    cmds << zwave.configurationV1.configurationSet(parameterNumber: ringParamMap.ringProximitySensor.Param, size: ringParamMap.ringProximitySensor.Size, configurationValue: [ ringProximitySensorDisable ? ringParamMap.ringProximitySensor.Disabled : ringParamMap.ringProximitySensor.Enabled ])
    cmds << zwave.configurationV1.configurationGet(parameterNumber: ringParamMap.ringProximitySensor.Param)

    cmds ? secureSequence(cmds) : cmds
}

def reLocked() {
    log.info "$device.displayName: Sending lock door notification as a follow up the unlocked event for the non motorized deadbolt" 
    def map = [ name: "lock", value: "locked", method: "auto", displayed: true ]
    sendEvent(map)
}

def activateSmoke(String msg) {
    log.info "$device.displayName: Activating smoke alarm sensor"
    sendEvent([ name: "smoke", value: "detected",  descriptionText: msg, displayed: true ])
}

def resetSmoke() {
    log.info "$device.displayName: Resetting smoke alarm sensor" 
    sendEvent([ name: "smoke", value: "clear",  descriptionText: "$device.displayName: Resetting smoke/fire alarm sensor", displayed: true ])
}

def resetTamper() {
    log.info "$device.displayName: Resetting door tampering activity sensor" 
    sendEvent([ name: "tamper", value: "clear",  descriptionText: "$device.displayName: Resetting door tampering activity sensor", displayed: true ])
}

// Creates emergency buttons child devices
private createChildDevices() {
    def childDevs = childDevices

    if (!childDevs) {
        try {
            if (isRingKeypad()) {
                log.info "Adding Ring 3 child device buttons"
                sendEvent(name: "numberOfButtons", value: 3, descriptionText: "Reporting 3 emergency buttons") // Initialize default
                sendEvent(name: "supportedButtonValues", value: [ "held" ].encodeAsJson(), descriptionText: "Initializing button") // Initialize default
                [ "Police", "Fire", "Medical" ].each {
                    def childDevice = addChildDevice(
                        "smartthings",
                        "Child Button",
                        "${device.deviceNetworkId}-button${it}",
                        device.hub.id,
                        [
                            completedSetup: true,
                            label: "${device.displayName} ${it} Button",
                            isComponent: !separateDevices
                        ] + (!separateDevices ? [ componentName: "${it}Button", componentLabel: "${it} button" ] : [:]) // Don't set this for isComponent is false
                    )
                    childDevice.sendEvent(name: "supportedButtonValues", value: [ "held" ].encodeAsJson(), descriptionText: "Initializing button") // Initialize default
                    childDevice.sendEvent(name: "button", value: "", descriptionText: "$childDevice.displayName Resetting button", displayed: true) // Reset the state
                }
            }
        } catch(Exception e) {
            log.error "Unable to create child devices: ${e}"
        }
    } else {
        log.trace "Installed child device: $childDevs"
    }
}

// NOTE: There appears to be a bug with the hub pairing where the zwInfo shows 0000 for mfr, prod and model. Until that is fixed use state.MSR as it is queried from the lock
/**
 * Utility function to check if the device manufacturer is Ring
 *
 * @return true if the keypad manufacturer is Ring, else false
 */
def isRingKeypad() {
	if (state.MSR?.startsWith("0346") || ("0346" == zwaveInfo.mfr)) {
		if ("Ring" != getDataValue("manufacturer")) {
			updateDataValue("manufacturer", "Ring")
		}
		return true
	}
	return false
}

/**
 * Utility function to convert a z-wave number value into a integer array
 */
private paramValue(value, bytes) {
    if (value == null || !(value instanceof Number)) {
        return null
    }

    //log.trace "Param value: $value, $bytes"

    List<Integer> ret = [] // We start with a Integer list and then convert to array (since arrays are fixed in size)
    for (int i=0; i<bytes; i++) {
        ret = [(((value as Long) >> (i*8)) & 0xFF) as Integer] + ret
    }

    //log.debug ret as Integer[]

    return ret as Integer[] // We need an integer array
}

/**
 * Utility function to convert a z-wave byte array into a number (long) value
 */
private reverseValue(value) {
    if (!value || !List.isCase(value)) {
        return null
    }

    //log.trace "Reverse value: $value, $bytes"

    Long ret = 0
    for (int i=0; i<value.size(); i++) {
        ret |= ((((value[i] as Integer) & 0xFF) as Long) << ((value.size() - 1 - i) * 8)) as Long
    }

    //log.debug ret

    return ret
}

private getRingParamMap(value = null) {
    [
        "ringRetries": 				[ Param: 2, Size: 1, Default: 1, Min: 0, Max: 5, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "ringRetryInterval":		[ Param: 3, Size: 1, Default: 5, Min: 1, Max: 60, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "ringAnnouncementVolume":	[ Param: 4, Size: 1, Default: 7, Min: 0, Max: 10, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "ringKeyToneVolume":		[ Param: 5, Size: 1, Default: 6, Min: 0, Max: 10, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "ringSirenVolume":			[ Param: 6, Size: 1, Default: 10, Min: 0, Max: 10, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "ringSpecialLongPressDuration":	[ Param: 7, Size: 1, Default: 3, Min: 2, Max: 5, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "ringLongPressDuration":	[ Param: 8, Size: 1, Default: 3, Min: 2, Max: 5, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "ringAmbientLightSensor":	[ Param: 14, Size: 1, Default: 20, Min: 0, Max: 100, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "ringProximitySensor":		[ Param: 15, Size: 1, Default: 1, Enabled: 1, Disabled: 0 ],
    ]
}

// THIS IS THE END OF THE FILE